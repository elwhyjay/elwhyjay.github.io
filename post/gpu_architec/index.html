<!DOCTYPE html>

<script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><style>
    .theme-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 8px;
      font-size: 1.2rem;
      cursor: pointer;
      background: none;
      border: 0px solid ;
      border-color: none;
      border-radius: 60%;
      z-index: 1000;
    }
    body[a="dark"] .theme-toggle {
        border-color: white;
    }
    body[a="dark"] #dark-icon {
        stroke: white;  
    }
</style>

<html lang="ko-kr"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="google-site-verification" content="CGHN0W7w6iWZ8ggs2E8eQ_Wiq1IuSxJHXr-KLZIetgk" />
   <meta name="description" content="Introduction
gpu programming을 하기위해서는 gpu architecture에 대한 이해가 필요하다. gpu가 무엇인지는 현재에와서는 모르는 사람이 없을것이다.
때문에 gpu에 대한 소개는 생략하고 gpu architecture를 곧바로 살펴보자
GPU Hardware Architecture
gpu architecture는 크게 다음과 같은 요소로 구성된다.

Streaming Multiprocessors (SMs): GPU의 핵심 컴퓨팅 유닛으로, 병렬 처리를 수행한다. 각 SM은 여러 개의 CUDA 코어를 포함하고 있으며, 동시에 여러 스레드를 실행할 수 있다.
HBM (High Bandwidth Memory): GPU의 글로벌 메모리로, 데이터 전송 속도가 매우 빠르다. HBM은 GPU와 CPU 간의 데이터 전송을 최적화하여 높은 성능을 제공한다. DRAM을 적층해 만든 구조로 CPU에서 DRAM의 역할과 유사하다.
L2 Cache: GPU의 L2 캐시는 데이터 접근 속도를 높이기 위해 사용된다. L2 캐시는 GPU와 HBM 사이의 중간 캐시 역할을 하며, 자주 사용되는 데이터를 저장하여 빠른 접근을 가능하게 한다.
NVLink: 다른 GPU와의 연결을 위한 인터페이스로 , 다중 GPU 시스템에서 높은 대역폭을 제공한다. NVLink는 GPU 간의 데이터 전송 속도를 향상시켜, 병렬 처리 성능을 극대화한다.

Streaming Multiprocessors (SMs)
SMs는 GPU의 핵심 컴퓨팅 유닛으로, 병렬 처리를 수행한다. 각 SM은 다음과 같은 구성 요소로 이루어져 있다:">  
  
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-YXXYQPDYLX"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-YXXYQPDYLX');
        }
      </script>

  <title>
    
      Gpu_architec
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/img/favicon.ico" />
  
  
  
  <link rel="stylesheet" href="/css/main.b27fc5610be205f24ca50ff0ec7c3029a919c277b959db7ed8b6e173d918decfc1435681e9a787476bce9650012878ff0a4ac9f8ac6f8e2ee2716f8eff5cead8.css" integrity="sha512-sn/FYQviBfJMpQ/w7HwwKakZwne5Wdt&#43;2Lbhc9kY3s/BQ1aB6aeHR2vOllABKHj/CkrJ&#43;Kxvji7icW&#43;O/1zq2A==" />
  
</head>
<style>
        table {
            border-collapse: collapse;
            border: 1px solid #ebebeb;
        }
        
        th, td {
            border: 1px solid #ffffff;
            padding: 8px;
        }
        th {
            background-color: #2290e5;
        }
        
    </style>
    
    <body a="auto">
        <button class="theme-toggle" onclick="toggleTheme()">
            <span class="light-icon">
                <svg id="light-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                stroke-linejoin="round">
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
            </svg>
            </span>
            <span class="dark-icon" style="display:none">
                <svg id="dark-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                stroke-linejoin="round">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                </svg>
            </span>
            
            
        </button>
        <main class="page-content" aria-label="Content">
            <div class="w">
<a href="/">..</a>


<article>
    <p class="post-meta">
        <time datetime="2025-08-06 12:22:45 &#43;0900 KST">
            2025-08-06
        </time>
    </p>

    <h1>Gpu_architec</h1>

    

    <h2 id="introduction">Introduction</h2>
<p>gpu programming을 하기위해서는 gpu architecture에 대한 이해가 필요하다. gpu가 무엇인지는 현재에와서는 모르는 사람이 없을것이다.
때문에 gpu에 대한 소개는 생략하고 gpu architecture를 곧바로 살펴보자</p>
<h2 id="gpu-hardware-architecture">GPU Hardware Architecture</h2>
<p>gpu architecture는 크게 다음과 같은 요소로 구성된다.</p>
<ul>
<li><strong>Streaming Multiprocessors (SMs)</strong>: GPU의 핵심 컴퓨팅 유닛으로, 병렬 처리를 수행한다. 각 SM은 여러 개의 CUDA 코어를 포함하고 있으며, 동시에 여러 스레드를 실행할 수 있다.</li>
<li><strong>HBM (High Bandwidth Memory)</strong>: GPU의 글로벌 메모리로, 데이터 전송 속도가 매우 빠르다. HBM은 GPU와 CPU 간의 데이터 전송을 최적화하여 높은 성능을 제공한다. DRAM을 적층해 만든 구조로 CPU에서 DRAM의 역할과 유사하다.</li>
<li><strong>L2 Cache</strong>: GPU의 L2 캐시는 데이터 접근 속도를 높이기 위해 사용된다. L2 캐시는 GPU와 HBM 사이의 중간 캐시 역할을 하며, 자주 사용되는 데이터를 저장하여 빠른 접근을 가능하게 한다.</li>
<li><strong>NVLink</strong>: 다른 GPU와의 연결을 위한 인터페이스로 , 다중 GPU 시스템에서 높은 대역폭을 제공한다. NVLink는 GPU 간의 데이터 전송 속도를 향상시켜, 병렬 처리 성능을 극대화한다.</li>
</ul>
<h3 id="streaming-multiprocessors-sms">Streaming Multiprocessors (SMs)</h3>
<p>SMs는 GPU의 핵심 컴퓨팅 유닛으로, 병렬 처리를 수행한다. 각 SM은 다음과 같은 구성 요소로 이루어져 있다:</p>
<ul>
<li><strong>CUDA Cores</strong>: SM 내에서 실제 연산을 수행하는 유닛이다. 하나의 코어는 단일 스레드의 연산을 처리한다.</li>
<li><strong>Tensor Cores</strong>: 딥러닝 연산을 가속화하기 위해 설계된 유닛으로, 행렬 연산을 효율적으로 처리한다. Tensor Cores는 FP16 및 INT8 데이터 타입을 지원하여 높은 성능을 제공한다.</li>
<li><strong>Warp</strong>: SM 내에서 실행되는 스레드 그룹으로, 32개의 스레드로 구성된다. 각 워프는 동시에 실행되며, GPU의 병렬 처리 능력을 극대화한다. 워프는 스케줄러에 의해 관리되며, 스레드 간의 동기화를 지원한다.</li>
<li><strong>Warp Scheduler</strong>: SM 내에서 실행될 스레드를 관리하는 유닛이다. 각 SM은 여러 개의 워프(32개의 스레드로 구성)를 동시에 실행할 수 있다.</li>
<li><strong>Registers</strong>: 각 CUDA 코어가 사용하는 로컬 메모리로, 빠른 데이터 접근을 가능하게 한다. 각 스레드는 자신의 레지스터를 사용하여 데이터를 저장하고 처리한다.</li>
<li><strong>L1 Cache</strong>: 각 SM 내에서 사용되는 캐시로, 데이터 접근 속도를 높이기 위해 사용된다. L1 캐시는 Shared Memory와 Registers의 역할을 하며, 자주 사용되는 데이터를 저장하여 빠른 접근을 가능하게 한다.</li>
<li><strong>Instruction Cache</strong>: SM 내에서 실행되는 명령어를 캐싱하여, 명령어 접근 속도를 높인다. 이 캐시는 자주 사용되는 명령어를 저장하여, 반복적인 연산의 성능을 향상시킨다.</li>
<li><strong>Texture Units</strong>: GPU에서 텍스처 데이터를 처리하는 유닛으로, 이미지 및 비디오 처리에 사용된다. 텍스처 유닛은 고속의 텍스처 캐시를 사용하여, 이미지 데이터를 효율적으로 처리한다.</li>
</ul>
<p>이 외에도 다른 구성 요소가 있지만, 위의 요소들이 GPU의 핵심적인 역할을 한다. 자세한 사항은 아래 그림을 참고하자.</p>
<p><img src="/img/A100_GA100_SM.png" alt="SM Architecture"></p>
<p>위 그림은 A100의 SM구조로 각 SM은 108개의 CUDA 코어, 4개의 Tensor Cores, 64KB의 L1 캐시 및 96KB의 Shared Memory를 갖추고 있다.</p>
<h2 id="gpu의-논리적-구조">GPU의 논리적 구조</h2>
<p>GPU의 하드웨어 구조를 살펴보았으니 GPU는 논리적으로 다음과 같은 구조를 살펴보자</p>
<ul>
<li><strong>Global Memory</strong>: GPU의 메인 메모리로, 모든 SM이 접근할 수 있는 데이터 저장 공간이다. Global Memory는 대용량 데이터를 저장할 수 있지만, 접근 속도가 상대적으로 느리다. GPU의 Global Memory는 CPU의 DRAM과 유사하다.</li>
<li><strong>Grid</strong>: GPU에서 실행되는 커널(함수) 실행의 논리적 단위로, 여러 개의 블록으로 구성된다.</li>
<li><strong>Block</strong>: 각 블록은 여러 개의 스레드로 구성되며, 동일한 Shared Memory를 공유한다. 블록은 GPU의 SM에 할당되어 병렬로 실행된다.</li>
<li><strong>Thread</strong>: 블록 내에서 실행되는 개별 스레드로, 각 스레드는 자신의 레지스터와 Shared Memory를 사용하여 연산을 수행한다. 각 스레드는 독립적으로 실행되며, 다른 스레드와 동기화가 필요하다. CUDA core 혹은 Tensor core 1개가 하나의 스레드를 처리한다.</li>
<li><strong>Shared Memory</strong>: 각 블록 내에서 사용되는 빠른 메모리로, 블록 내의 모든 스레드가 공유할 수 있다. Shared Memory는 Global Memory보다 빠른 접근 속도를 제공하며, 블록 내의 스레드 간 데이터 공유를 가능하게 한다. SM내에 L1 캐시와 함께 존재하며, 메모리의 크기는 GPU의 Compute Capability에 따라 다르다. 예를 들어, Compute Capability 7.0인 A100 GPU는 각 SM당 192KB의 shared meomory/ L1 캐시를 갖는다. A100의 경우 Shared memory에 0 KB에서 164KB까지 할당할 수 있다.[^3]</li>
<li><strong>Register</strong>: 각 스레드가 사용하는 로컬 메모리로, 가장 빠른 데이터 접근 속도를 제공한다. 레지스터는 각 스레드의 상태를 저장하며, 연산에 필요한 데이터를 임시로 저장한다.</li>
<li><strong>Local Memory</strong>: 각 스레드가 사용하는 메모리로, 레지스터에 저장할 수 없는 큰 데이터나 배열을 저장하는 데 사용된다. Local Memory는 Global Memory보다 느리지만, Shared Memory보다 빠르다. Compute capability 2.0 이상인 GPU의 경우, local memory 데이터는 SM의 L1 캐시와 device L2 캐시에 저장된다.</li>
</ul>
<h3 id="나중에-살펴볼-자료">나중에 살펴볼 자료</h3>
<p>H100 이후에 생긴 GPU 아키텍쳐의 특징이있다. 다음에 살펴보자</p>
<ul>
<li><strong>Distributed Shared Memory</strong>: H100 GPU는 Distributed Shared Memory를 도입하여, 여러 GPU 간의 메모리 공유를 가능하게 한다. 이를 통해 다중 GPU 시스템에서 데이터 전송 속도를 향상시킨다.</li>
<li><strong>Thread Block Clustering</strong>: 여러 SM에서 실행되는 스레드 블록을 클러스터링하여 제어할수 있게해준다.</li>
</ul>
<h3 id="gpu-데이터-흐름">GPU 데이터 흐름</h3>
<p>GPU의 데이터 흐름은 다음 그림과 같다.<br>
<img src="/img/gpu_data_flow.png" alt="GPU Data Flow"></p>
<p>Host, 즉 CPU로 부터 할당받은 데이터를 GPU의 Global Memory, Texture memory, Constant memory에 올린다. 이 메모리의 데이터는 Block내의 Thread가 접근할 수 있다.
각 <strong>Block은 SM에 할당되어 병렬로 실행되며</strong>, 각 Block 내의 Thread는 Shared Memory를 통해 데이터를 공유한다. 각 Thread는 자신의 레지스터를 사용하여 연산을 수행한다.</p>
<hr>
<h1 id="references">References</h1>
<ol>
<li><a href="https://images.nvidia.com/aem-dam/en-zz/Solutions/data-center/nvidia-ampere-architecture-whitepaper.pdf">NVIDIA A100 Tensor Core GPU Architecture</a></li>
<li><a href="https://dlsys.cs.washington.edu/pdf/lecture5.pdf">Washington Univ CSE599W: Spring 2018 Lecture 5 slides</a></li>
<li><a href="https://docs.nvidia.com/cuda/ampere-tuning-guide/contents.html">NVIDIA CUDA Guide</a></li>
<li><a href="https://developer.nvidia.com/blog/nvidia-ampere-architecture-in-depth/">NVIDIA Technical Blog - NVIDIA Ampere Architecture In-Depth</a></li>
<li><a href="https://developer.nvidia.com/blog/nvidia-hopper-architecture-in-depth/">NVIDIA Technical Blog - NVIDIA Hopper Architecture In-Depth</a></li>
<li><a href="https://junstar92.tistory.com/283">별준 블로그</a></li>
</ol>

</article>


    <script src="https://utteranc.es/client.js"
        repo="elwhyjay/blog-comment"
        issue-term="title"
        label="✨💬✨"
        theme="github-dark"
        crossorigin="anonymous"
        async>
</script>


            </div>
        </main>
        <script>
            function toggleTheme() {
              const body = document.querySelector('body');
              const currentTheme = body.getAttribute('a');
              const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
              
              body.setAttribute('a', newTheme);
              localStorage.setItem('theme', newTheme);
              
              
              const lightIcon = document.querySelector('.light-icon');
              const darkIcon = document.querySelector('.dark-icon');
              lightIcon.style.display = newTheme === 'dark' ? 'none' : 'inline';
              darkIcon.style.display = newTheme === 'dark' ? 'inline' : 'none';
            }
            
            
            document.addEventListener('DOMContentLoaded', () => {
              const savedTheme = localStorage.getItem('theme');
              if (savedTheme) {
                document.querySelector('body').setAttribute('a', savedTheme);
                
                const lightIcon = document.querySelector('.light-icon');
                const darkIcon = document.querySelector('.dark-icon');
                lightIcon.style.display = savedTheme === 'dark' ? 'none' : 'inline';
                darkIcon.style.display = savedTheme === 'dark' ? 'inline' : 'none';
              }
            });
        </script>
    </body>
</html>
